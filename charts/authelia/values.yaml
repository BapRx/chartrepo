## Image Parameters
## ref: https://hub.docker.com/r/authelia/authelia/tags/
##
image:
  registry: docker.io
  repository: authelia/authelia
  tag: 4.26.1
  pullPolicy: IfNotPresent
  pullSecrets: [ ]
  # pullSecrets:
  #   - myPullSecretName

# nameOverride: authelia-deployment-name
# appNameOverride: authelia


extraAnnotations: { }
# extraAnnotations:
#   myAnnotation: myValue

##
## extra labels/annotations applied to all resources
##
extraLabels: { }
# extraLabels:
#   myLabel: myValue

service:
  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  port: 80

  # clusterIP:


ingress:
  enabled: false

  annotations: { }
  # annotations:
  #   kubernetes.io/ingress.class: nginx
  #   kubernetes.io/tls-acme: "true"

  labels: { }
  # labels:
  #   myLabel: myValue

  certManager: false
  rewriteTarget: true

  ## Subdomain is the only thing required since we specify the domain as part of the configuration section.
  ## Example: To get Authelia to listen on https://auth.example.com specify 'auth' for subdomain,
  ## and specify example.com for the configuration.domain.

  subdomain: auth
  tls: true
  tlsSecret: authelia-tls

  traefikCRD:
    enabled: false

    # matchOverride: Host(`auth.example.com`) && PathPrefix(`/`)

    entrypoints: [ ]
    # entrypoints:
    # - http

    # priority: 10

    # weight: 10

    sticky: false

    # stickyCookieNameOverride: authelia_traefik_lb

    # strategy: RoundRobin

    # responseForwardingFlushInterval: 100ms

    middlewares:
      auth:
        # nameOverride: authelia-auth
        authResponseHeaders:
        - Remote-User
        - Remote-Name
        - Remote-Email
        - Remote-Groups

      chains:
        auth:
          # nameOverride: authelia-auth-chain

          # List of Middlewares to apply before the forwardAuth Middleware in the authentication chain.
          before: [ ]
          # before:
          # - name: extra-middleware-name
          #   namespace: default

          # List of Middlewares to apply after the forwardAuth Middleware in the authentication chain.
          after: [ ]
          # after:
          # - name: extra-middleware-name
          #   namespace: default

        ingressRoute:

          # List of Middlewares to apply before the middleware in the IngressRoute chain.
          before: [ ]
          # before:
          # - name: extra-middleware-name
          #   namespace: default

          # List of Middlewares to apply after the middleware in the IngressRoute chain.
          after: [ ]
          # after:
          # - name: extra-middleware-name
          #   namespace: default

    tls:
      #   secretName: traefik-example-com-wildcard
      #   existingOptions
      #     name: default-traefik-options
      #     namespace: default
      #   certResolver: default
      #   domains:
      #   - main: example.com
      #     sans:
      #     - *.example.com
      #
      options: { }
      #   nameOverride: authelia-tls-options
      #   minVersion: VersionTLS12
      #   maxVersion: VersionTLS13
      #   curvePreferences:
      #   - CurveP521
      #   - CurveP384
      #   cipherSuites:
      #   - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      #   - TLS_RSA_WITH_AES_256_GCM_SHA384
      #   sniStrict: true

pod:
  kind: DaemonSet

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  replicas: 1
  revisionHistoryLimit: 5

  updateStrategy: RollingUpdate

  securityContext:
    container:
      runAsUser: 2000
      runAsGroup: 2000
      fsGroup: 2000
    pod:
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      privileged: false

  tolerations: [ ]
  # tolerations:
  # - key: key1
  #   operator: Equal
  #   value: value1
  #   effect: NoSchedule
  #   tolerationSeconds: 3600

  selectors:
  #   nodeName: worker-1

    nodeSelector: {}
    # nodeSelector:
    #   disktype: ssd
    #   kubernetes.io/hostname: worker-1

    affinity:
      nodeAffinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchExpressions:
      #       - key: kubernetes.io/hostname
      #         operator: In
      #         values:
      #         - worker-1
      #         - worker-2
      #   preferredDuringSchedulingIgnoredDuringExecution:
      #   - weight: 1
      #     preference:
      #       matchExpressions:
      #       - key: node-label-key
      #         operator: NotIn
      #         values:
      #         - not-this
      podAffinity: {}
      # podAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #   - labelSelector:
      #       matchExpressions:
      #       - key: security
      #         operator: In
      #         values:
      #         - S1
      #     topologyKey: topology.kubernetes.io/zone
      podAntiAffinity: {}
      # podAntiAffinity:
      #     preferredDuringSchedulingIgnoredDuringExecution:
      #     - weight: 100
      #       podAffinityTerm:
      #         labelSelector:
      #           matchExpressions:
      #           - key: security
      #             operator: In
      #             values:
      #             - S2
      #         topologyKey: topology.kubernetes.io/zone

  env: [ ]
  # env:
  # - name: TZ
  #   value: Australia/Melbourne

  resources:
    limits: { }
    # limits:
    #   cpu: "4.00"
    #   memory: 125Mi
    requests: { }
    # requests:
    #   cpu: "0.25"
    #   memory: 50Mi

  probes:
    method:
      httpGet:
        path: /api/health
        port: http
        scheme: HTTP

    liveness:
      initialDelaySeconds: 5
      periodSeconds: 30
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 5

    readiness:
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 5

    ## Note: Startup Probes are generally not enabled unless you enable them manually in the kubelet.
    # startup:
    #   initialDelaySeconds: 20
    #   periodSeconds: 5
    #   timeoutSeconds: 5
    #   successThreshold: 1
    #   failureThreshold: 6

  extraVolumeMounts: [ ]
  extraVolumes: [ ]

##
## Kubernetes Pod Disruption Budget
##
podDisruptionBudget:
  enabled: false

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  # minAvailable: 1
  # maxUnavailable: 1

##
## Kubernetes Network Policy
##
networkPolicy:
  enabled: false

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          authelia.com/network-policy: namespace
    - podSelector:
        matchLabels:
          authelia.com/network-policy: pod
    ports:
    - protocol: TCP
      port: 9091


##
## Authelia Config Map Generator
##
configMap:

  # Enable the configMap source for the Authelia config.
  # If this is false you need to provide a volumeMount via PV/PVC or other means that mounts to /config.
  enabled: true

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  # key: configuration.yml

  # existingConfigMap:

  ##
  ## Port sets the configured port for the daemon, service, and the probes.
  ## Default is 9091 and should not need to be changed.
  ##
  # port: 9091

  ##
  ## Domain is used to set the domain for the session, and defaults for the default_redirection_url, and totp issuer.
  ##
  domain: example.com

  ## Configuration options specific to the internal http server
  server:
    ## Buffers usually should be configured to be the same value.
    ## Explanation at https://docs.authelia.com/configuration/server.html
    ## Read buffer size configures the http server's maximum incoming request size in bytes.
    read_buffer_size: 4096
    ## Write buffer size configures the http server's maximum outgoing response size in bytes.
    write_buffer_size: 4096
    ## Set the single level path Authelia listens on, must be alphanumeric chars and should not contain any slashes.
    path: ""

  ## Level of verbosity for logs: info, debug, trace
  log_level: info
  ## Format the logs are written as: json, text
  log_format: text

  ## Default redirection URL
  ##
  ## If user tries to authenticate without any referer, Authelia
  ## does not know where to redirect the user to at the end of the
  ## authentication process.
  ## This parameter allows you to specify the default redirection
  ## URL Authelia will use in such a case.
  ##
  ## Note: this parameter is optional. If not provided, user won't
  ## be redirected upon successful authentication.
  ## Default is https://<config.domain> (value above in this chart).
  ##
  # default_redirection_url: https://example.com

  ## TOTP Settings
  ##
  ## Parameters used for TOTP generation
  totp: { }
    ## The issuer name displayed in the Authenticator application of your choice
    ## See: https://github.com/google/google-authenticator/wiki/Key-Uri-Format for more info on issuer names
    ## Defaults to <config.domain>.
    ##
    # issuer: example.com

    ## The period in seconds a one-time password is current for. Changing this will require all users to register
    ## their TOTP applications again.
    ## Warning: before changing period read the docs link below.
  # period: 30

  ## The skew controls number of one-time passwords either side of the current one that are valid.
  ## Warning: before changing skew read the docs link below.
  # skew: 1

  ##  See: https://docs.authelia.com/configuration/one-time-password.html#period-and-skew to read the documentation.

  ##
  ## Duo Push API
  ##
  ## Parameters used to contact the Duo API. Those are generated when you protect an application
  ## of type "Partner Auth API" in the management panel.
  duo_api:
    hostname: api-123456789.example.com
    integration_key: ABCDEF

  ## The authentication backend to use for verifying user passwords
  ## and retrieve information such as email address and groups
  ## users belong to.
  ##
  ## There are two supported backends: 'ldap' and 'file'.
  authentication_backend:
    ## Disable both the HTML element and the API for reset password functionality
    disable_reset_password: false

    ## The amount of time to wait before we refresh data from the authentication backend. Uses duration notation.
    ## To disable this feature set it to 'disable', this will slightly reduce security because for Authelia, users
    ## will always belong to groups they belonged to at the time of login even if they have been removed from them in LDAP.
    ## To force update on every request you can set this to '0' or 'always', this will increase processor demand.
    ## See the below documentation for more information.
    ## Duration Notation docs:  https://docs.authelia.com/configuration/index.html#duration-notation-format
    ## Refresh Interval docs: https://docs.authelia.com/configuration/authentication/ldap.html#refresh-interval
    refresh_interval: 5m

    ## LDAP backend configuration.
    ##
    ## This backend allows Authelia to be scaled to more
    ## than one instance and therefore is recommended for
    ## production.
    ldap:
      ## The LDAP implementation, this affects elements like the attribute utilised for resetting a password.
      ## Acceptable options are as follows:
      ## - 'activedirectory' - For Microsoft Active Directory.
      ## - 'custom' - For custom specifications of attributes and filters.
      ## This currently defaults to 'custom' to maintain existing behaviour.
      ##
      ## Depending on the option here certain other values in this section have a default value, notably all
      ## of the attribute mappings have a default value that this config overrides, you can read more
      ## about these default values at https://docs.authelia.com/configuration/authentication/ldap.html#defaults
      # implementation: custom

      ## The url to the ldap server. Scheme can be ldap or ldaps in the format (port optional) <scheme>://<address>[:<port>].
      url: ldap://openldap.default.svc.cluster.local

      ## Use StartTLS with the LDAP connection.
      # start_tls: false

      # tls:
      #   server_name: openldap.default.svc.cluster.local
      #   minimum_version: TLS1.2
      #   skip_verify: false

      ## The base dn for every entries.
      base_dn: DC=example,DC=com

      ## The attribute holding the username of the user. This attribute is used to populate
      ## the username in the session information. It was introduced due to #561 to handle case
      ## insensitive search queries.
      ## For you information, Microsoft Active Directory usually uses 'sAMAccountName' and OpenLDAP
      ## usually uses 'uid'
      ## Beware that this attribute holds the unique identifiers for the users binding the user and the configuration
      ## stored in database. Therefore only single value attributes are allowed and the value
      ## must never be changed once attributed to a user otherwise it would break the configuration
      ## for that user. Technically, non-unique attributes like 'mail' can also be used but we don't recommend using
      ## them, we instead advise to use the attributes mentioned above (sAMAccountName and uid) to follow
      ## https://www.ietf.org/rfc/rfc2307.txt.
      ## username_attribute: uid

      ## An additional dn to define the scope to all users.
      # additional_users_dn: OU=Users

      ## The users filter used in search queries to find the user profile based on input filled in login form.
      ## Various placeholders are available to represent the user input and back reference other options of the configuration:
      ## - {input} is a placeholder replaced by what the user inputs in the login form.
      ## - {username_attribute} is a mandatory placeholder replaced by what is configured in `username_attribute`.
      ## - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`.
      ##
      ## Recommended settings are as follows:
      ## - Microsoft Active Directory: (&({username_attribute}={input})(objectCategory=person)(objectClass=user))
      ## - OpenLDAP: (&({username_attribute}={input})(objectClass=person))' or '(&({username_attribute}={input})(objectClass=inetOrgPerson))
      ##
      ## To allow sign in both with username and email, one can use a filter like
      ## (&(|({username_attribute}={input})({mail_attribute}={input}))(objectClass=person))
      # users_filter: (&({username_attribute}={input})(objectClass=person))

      ## An additional dn to define the scope of groups.
      # additional_groups_dn: OU=Groups

      ## The groups filter used in search queries to find the groups of the user.
      ## - {input} is a placeholder replaced by what the user inputs in the login form.
      ## - {username} is a placeholder replace by the username stored in LDAP (based on `username_attribute`).
      ## - {dn} is a matcher replaced by the user distinguished name, aka, user DN.
      ## - {username_attribute} is a placeholder replaced by what is configured in `username_attribute`.
      ## - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`.
      # groups_filter: (&(member={dn})(objectclass=groupOfNames))

      ## The attribute holding the name of the group
      ## group_name_attribute: cn

      ## The attribute holding the mail address of the user. If multiple email addresses are defined for a user, only the first
      ## one returned by the LDAP server is used.
      ## mail_attribute: mail

      ## The attribute holding the display name of the user. This will be used to greet an authenticated user.
      ## display_name_attribute: displayname

      ## The username and password of the admin user.
      user: CN=Authelia,DC=example,DC=com

    # File backend configuration.
    #
    # With this backend, the users database is stored in a file
    # which is updated when users reset their passwords.
    # Therefore, this backend is meant to be used in a dev environment
    # and not in production since it prevents Authelia to be scaled to
    # more than one instance. The options under 'password' have sane
    # defaults, and as it has security implications it is highly recommended
    # you leave the default values. Before considering changing these settings
    # please read the docs page below:
    # https://docs.authelia.com/configuration/authentication/file.html#password-hash-algorithm-tuning
    ##
    ## ** WARNING **
    ## Not using this authentication backend provider makes Authelia stateful.
    ## If you use this in Kubernetes you SHOULD either use a single replica StatefulSet or disable password resets
    ## otherwise you risk major issues.
    ##
    # file:
    #   path: /config/users_database.yml
    #   password:
    #     algorithm: argon2id
    #     iterations: 1
    #     key_length: 32
    #     salt_length: 16
    #     memory: 1024
    #     parallelism: 8
  ##
  ## Access Control
  ##
  ## Access control is a list of rules defining the authorizations applied for one
  ## resource to users or group of users.
  ##
  ## If 'access_control' is not defined, ACL rules are disabled and the 'bypass'
  ## rule is applied, i.e., access is allowed to anyone. Otherwise restrictions follow
  ## the rules defined.
  ##
  ## Note: One can use the wildcard * to match any subdomain.
  ## It must stand at the beginning of the pattern. (example: *.mydomain.com)
  ##
  ## Note: You must put patterns containing wildcards between simple quotes for the YAML
  ## to be syntactically correct.
  ##
  ## Definition: A 'rule' is an object with the following keys: 'domain', 'subject',
  ## 'policy' and 'resources'.
  ##
  ## - 'domain' defines which domain or set of domains the rule applies to.
  ##
  ## - 'subject' defines the subject to apply authorizations to. This parameter is
  ##    optional and matching any user if not provided. If provided, the parameter
  ##    represents either a user or a group. It should be of the form 'user:<username>'
  ##    or 'group:<groupname>'.
  ##
  ## - 'policy' is the policy to apply to resources. It must be either 'bypass',
  ##   'one_factor', 'two_factor' or 'deny'.
  ##
  ## - 'resources' is a list of regular expressions that matches a set of resources to
  ##    apply the policy to. This parameter is optional and matches any resource if not
  ##    provided.
  ##
  ## Note: the order of the rules is important. The first policy matching
  ## (domain, resource, subject) applies.
  access_control:
    ## Default policy can either be 'bypass', 'one_factor', 'two_factor' or 'deny'.
    ## It is the policy applied to any resource if there is no policy to be applied
    ## to the user.
    default_policy: deny

    rules:
    ## Rules applied to everyone
    - domain: public.example.com
      policy: bypass

    - domain: secure.example.com
      policy: one_factor
      ## Network based rule, if not provided any network matches.
      networks:
      - 192.168.1.0/24

    - domain:
      - secure.example.com
      - private.example.com
      policy: two_factor

    - domain: singlefactor.example.com
      policy: one_factor

    ## Rules applied to 'admins' group
    - domain: "mx2.mail.example.com"
      subject: "group:admins"
      policy: deny

    - domain: "*.example.com"
      subject:
      - "group:admins"
      - "group:moderators"
      policy: two_factor

    ## Rules applied to 'dev' group
    - domain: dev.example.com
      resources:
      - "^/groups/dev/.*$"
      subject: "group:dev"
      policy: two_factor

    ## Rules applied to user 'john'
    - domain: dev.example.com
      resources:
        - "^/users/john/.*$"
      subject: "user:john"
      policy: two_factor

    ## Rules applied to user 'harry'
    - domain: dev.example.com
      resources:
      - "^/users/harry/.*$"
      subject: "user:harry"
      policy: two_factor

    ## Rules applied to user 'bob'
    - domain: "*.mail.example.com"
      subject: "user:bob"
      policy: two_factor
    - domain: "dev.example.com"
      resources:
      - "^/users/bob/.*$"
      subject: "user:bob"
      policy: two_factor

  ##
  ## Configuration of session cookies
  ##
  ## The session cookies identify the user once logged in.
  ##
  session:
    ##
    ## The name of the session cookie. (default: authelia_session).
    ##
    name: authelia_session

    ##
    ## Duration notation is mentioned in the following section: https://docs.authelia.com/configuration/index.html#duration-notation-format
    ##

    ##
    ## The time in seconds or duration notation before the cookie expires and session is reset.
    ##
    expiration: 1h

    ##
    ## The inactivity time in seconds or duration notation before the session is reset.
    ##
    inactivity: 5m

    ## The remember me duration.
    ## Value is in seconds or duration notation. Value of 0 disables remember me.
    ## Longer periods are considered less secure because a stolen cookie will last longer giving attackers more time to spy
    ## or attack. Currently the default is 1M or 1 month.
    remember_me_duration: 1M

    ## Redis Session Provider
    ##
    ## Currently the only session providers are redis and memory.
    ## If you don't define this section Authelia uses the memory provider, making Authelia stateful.
    ##
    ## ** WARNING **
    ## Not using this session provider makes Authelia stateful.
    ## If you do not use this in Kubernetes you SHOULD use a single replica StatefulSet otherwise you risk major issues.
    redis:
      host: redis.databases.svc.cluster.local
      port: 6379
      ## This is the Redis DB Index https://redis.io/commands/select (sometimes referred to as database number, DB, etc).
      database_index: 0

  ## Configuration of the authentication regulation mechanism.
  ##
  ## This mechanism prevents attackers from brute forcing the first factor.
  ## It bans the user if too many attempts are done in a short period of
  ## time.
  regulation:
    ## The number of failed login attempts before user is banned.
    ## Set it to 0 to disable regulation.
    max_retries: 3

    ## The time range during which the user can attempt login before being banned.
    ## The user is banned if the authentication failed 'max_retries' times in a 'find_time' seconds window.
    ## Value is in seconds or duration notation.
    find_time: 2m

    ## The length of time before a banned user can login again.
    ## Value is in seconds or duration notation.
    ban_time: 5m

  ## Configuration of the storage provider used to store data and secrets.
  ##
  ## The available providers are local, mysql, or postgres.
  ## You must use one of these providers, and you must not use more than one.
  storage:
    ## Local Storage Provider
    ##
    ## This stores the data in a SQLite3 Database.
    ## This is only recommended for lightweight non-stateful installations.
    ##
    ## ** WARNING **
    ## Use of this storage provider in makes Authelia stateful.
    ## If you use this in Kubernetes you MUST use a StatefulSet otherwise you risk major issues.
    # local:
    #  ## The directory where the DB files will be saved
    #  path: /config/db.sqlite3

    ## MySQL Storage Provider
    ##
    ## Supports both MySQL and MariaDB.
    ## MySQL or PostgreSQL are the recommended storage providers for production environments.
    mysql:
      host: mysql.databases.svc.cluster.local
      port: 3306
      database: authelia
      username: authelia

    ## PostgreSQL Storage Provider
    ##
    ## MySQL or PostgreSQL are the recommended storage providers for production environments.
    # postgres:
    #   host: postgres.databases.svc.cluster.local
    #   port: 5432
    #   database: authelia
    #   username: authelia
    #   sslmode: disable

  ## Configuration of the notification system.
  ##
  ## Notifications are sent to users when they require a password reset, a u2f
  ## registration or a TOTP registration.
  notifier:
    ## You can disable the notifier startup check by setting this to true.
    disable_startup_check: false

    ## Use a SMTP server for sending notifications. Authelia uses PLAIN or LOGIN method to authenticate.
    ## [Security] By default Authelia will:
    ##   - force all SMTP connections over TLS including unauthenticated connections
    ##      - use the disable_require_tls boolean value to disable this requirement (only works for unauthenticated connections)
    ##   - validate the SMTP server x509 certificate during the TLS handshake against the hosts trusted certificates
    ##     - trusted_cert option:
    ##       - this is a string value, that may specify the path of a PEM format cert, it is completely optional
    ##       - if it is not set, a blank string, or an invalid path; will still trust the host machine/containers cert store
    ##     - defaults to the host machine (or docker container's) trusted certificate chain for validation
    ##     - use the trusted_cert string value to specify the path of a PEM format public cert to trust in addition to the hosts trusted certificates
    ##     - use the disable_verify_cert boolean value to disable the validation (prefer the trusted_cert option as it's more secure)
    smtp:
      username: test
      host: smtp.mail.svc.cluster.local
      port: 25
      sender: admin@example.com
      ## HELO/EHLO Identifier. Some SMTP Servers may reject the default of localhost.
      # identifier: localhost
      ## Subject configuration of the emails sent.
      ## {title} is replaced by the text from the notifier
      # subject: "[Authelia] {title}"
      ## This address is used during the startup check to verify the email configuration is correct. It's not important what it is except if your email server only allows local delivery.
      startup_check_address: test@authelia.com
      # disable_require_tls: false
      # disable_html_emails: false
      # tls:
      #   server_name: smtp.mail.svc.cluster.local
      #   minimum_version: TLS1.2
      #   skip_verify: false


##
## Authelia Secret Generator.
##
## If both the values and existingSecret are not defined, this chart randomly generates a new secret on each
## install. It is recommended that you use something like sealed-secrets (https://github.com/bitnami-labs/sealed-secrets)
## and use the existingSecrets. All secrets can be stored in a single k8s secret if desired using the key option.
##
secret:
  # existingSecret: authelia

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  jwt:
    key: JWT_TOKEN
    # value:
  ldap:
    key: LDAP_PASSWORD
    # value:
  storage:
    key: STORAGE_PASSWORD
    # value:
  session:
    key: SESSION_ENCRYPTION_KEY
    # value:
  duo:
    key: DUO_API_KEY
    # value:
  redis:
    enabled: false
    key: REDIS_PASSWORD
    # value:
  smtp:
    enabled: false
    key: SMTP_PASSWORD
    # value:

certificates:
  # existingSecret: authelia

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  values: { }
  # values:
  # - name: Example_Com_Root_Certificate_Authority_B64.pem
  #   secretValue: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURYekNDQWtlZ0F3SUJBZ0lMQkFBQUFBQUJJVmhUQ0tJd0RRWUpLb1pJaHZjTkFRRUxCUUF3VERFZ01CNEcKQTFVRUN4TVhSMnh2WW1Gc1UybG5iaUJTYjI5MElFTkJJQzBnVWpNeEV6QVJCZ05WQkFvVENrZHNiMkpoYkZOcApaMjR4RXpBUkJnTlZCQU1UQ2tkc2IySmhiRk5wWjI0d0hoY05NRGt3TXpFNE1UQXdNREF3V2hjTk1qa3dNekU0Ck1UQXdNREF3V2pCTU1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUcKQTFVRUNoTUtSMnh2WW1Gc1UybG5iakVUTUJFR0ExVUVBeE1LUjJ4dlltRnNVMmxuYmpDQ0FTSXdEUVlKS29aSQpodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU13bGRwQjVCbmdpRnZYQWc3YUV5aWllL1FWMkVjV3RpSEw4ClJnSkR4N0tLblFSZkpNc3VTK0ZnZ2tiaFVxc01nVWR3Yk4xazBldjFMS01QZ2owTUs2NlgxN1lVaGhCNXV6c1QKZ0hlTUNPRkowbXBpTHg5ZStwWm8zNGtubFRpZkJ0Yyt5Y3NtV1ExejNyREk2U1lPZ3hYRzcxdUwwZ1JneWttbQpLUFpwTy9iTHlDaVI1WjJLWVZjM3JIUVUzSFRnT3U1eUx5NmMrOUM3di9VOUFPRUdNK2lDSzY1VHBqb1djNHpkClFRNGdPc0MwcDZIcHNrK1FMakpnNlZmTHVRU1NhR2psT0NaZ2RiS2ZkLytSRk8rdUlFbjhyVUFWU05FQ01XRVoKWHJpWDc2MTN0MlNhZXI5ZndSUHZtMkw3RFd6Z1ZHa1dxUVBhYnVtRGszRjJ4bW1GZ2hjQ0F3RUFBYU5DTUVBdwpEZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkRXdFQi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZJL3dTMytvCkxrVWtyazFRK21PYWk5N2kzUnU4TUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCTFFOdkFVS3IreUF6djk1WlUKUlVtN2xnQUpRYXl6RTRhR0tBY3p5bXZtZExtNkFDMnVwQXJUOWZIeEQ0cS9jMmRLZzhkRWUzamdyMjVzYndNcApqak01UmNPTzVMbFhiS3I4RXBic1U4WXQ1Q1JzdVpSais5eFRhR2RXUG9PNHp6VWh3OGxvL3M3YXdsT3F6SkNLCjZmQmRSb3lWM1hwWUtCb3ZIZDdOQURkQmorMUViZGRUS0pkKzgyY0VIaFhYaXBhMDA5NU1KNlJNRzNOemR2UVgKbWNJZmVnN2pMUWl0Q2h3cy96eXJWUTRQa1g0MjY4TlhTYjdoTGkxOFlJdkRRVkVUSTUzTzl6SnJsQUdvbWVjcwpNeDg2T3lYU2hrRE9PeXlHZU1saEx4UzY3dHRWYjkrRTdnVUpUYjBvMkhMTzAySlFaUjdya3BlRE1kbXp0Y3BICldEOWYKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==
  # - name: Example_Com_Root_Certificate_Authority.pem
  #   value: |
  #     -----BEGIN CERTIFICATE-----
  #     MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
  #     A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
  #     Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
  #     MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
  #     A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
  #     hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
  #     RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
  #     gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
  #     KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
  #     QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
  #     XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
  #     DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
  #     LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
  #     RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
  #     jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
  #     6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
  #     mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
  #     Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
  #     WD9f
  #     -----END CERTIFICATE-----

##
## Authelia Persistence Configuration.
##
## Useful in scenarios where you need persistent storage.
## Auth Provider Use Case: file; we recommend you use the ldap provider instead.
## Storage Provider Use Case: local; we recommend you use the mysql/mariadb or postgres provider instead.
## Configuration Use Case: when you want to manually configure the configuration entirely (set configMap.enabled = false).
##
persistence:
  enabled: false

  annotations: { }
  # annotations:
  #   myAnnotation: myValue

  labels: { }
  # labels:
  #   myLabel: myValue

  readOnly: false
  # subPath:
  # storageClass: "."

  # existingClaim:

  accessModes:
  - ReadWriteOnce

  size: 100Mi

  selector: { }
